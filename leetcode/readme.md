
- 时间复杂度
    O() 表示**上界**  Ω() 表示下界 之所以用O()表示一般情况是因为业内有规范 这种算法基本处理情况导致的
    递归的时间复杂度 —> 递归**树**的节点数量即 递归次数 * 操作的时间复杂度
    递归算法想要降低时间复杂度需要**抽离**递归操作保存结果 让一半的子树消失
    logn以谁为底没区别，因为可以通过对数计算剥离常数 log以2为底10 * log以10为底n === log以2为底n

- 空间复杂度
    递归算法的空间复杂度计算方式为： 递归深度 * 每次递归的空间复杂度
    递归深度就是递归树的深度, 因为递归操作实际上是函数在栈中的操作

- array的存储机构
    - 快数组：线性数据结构，而且以连续空间存储数据，是创建数组的**默认**形式
    - 慢数组：一个hashtable
    - 所以[1,2,1,3,...].splice(1,1) 的时间复杂度是？ o(n)?

# 数组
- 二分查找
    - 二分是建立在有序数组的情况下的，可以复习下数组排序(7种)
    - [left, right] 左闭右闭区间 while(left <= right) 因为left === right 有意义
    - [left, right) 左闭右开区间 while(left < right) 因为left === right 没有意义直接退出
    - 二分查找需要保证**循环不变量**原则：每次while操作都需要**坚持区间的定义**来进行操作
    - 二分每次操作数组长度都会减半 /2 所以时间复杂度为O(logn)
    - 推荐例题：


## 数组排序
    - 冒泡排序

    - 选择排序

    - 插入排序

    - 希尔排序

    - 归并排序

    - 堆排序

    - 快速排序


