# 动态规划

- 斐波那契数(509)
    1. dp[i]为数列第i个值 数组下标i为数列的下标
    2. 递推公式: f(n) = f(n - 1) + f(n - 2) n>=2
    3. 初始化 f(0)=0,f(1)=1
    4. 遍历顺序 从前往后 后面的值需要前面的值来得到
    5. 打印数组，举例推导dp数组
    6. 处理边界条件  n === 0  n === 1



- 爬楼梯(70)
    1. dp[i] i是楼层数  dp[i] 表示第i层的方法数
    2. 递推公式 dp[i] = dp[i-1] + dp[i-2]
    3. 初始化 dp[1] = 1 d[2] = 2   n >= 3
    4. 遍历顺序 从小到大 因为第n层需要之前层的方法数
    5. 打印数组，举例推导dp数组
    6. 处理边界条件  n === 0 n === 1


- 使用最小花费爬楼梯(746)
    1. dp[i]数组表示到达第i阶的最低花费为dp[i]
    2. 递推公式：dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
    3. 初始化：dp[0] = 0 dp[1] = 1   n < cost.length
    4. 遍历顺序 从前往后遍历 因为后面的数依赖前面的数的结果
    5. 打印数组，举例推导dp数组
    6. 边界条件 题目描述cost.length >= 2 故无额外边界处理

- 不同路径(62)
    1. dp[m][n] 代表到m行n列的路径数
    2. 递推公式 dp[m][n] = m-1<0?0:dp[m-1][n] + n-1<0?0:dp[m][n-1]
    3. 初始化 初始化dp[0][0] = 1
    4. 遍历顺序为从左到右，从上到下遍历
    5. 打印，错误示例：dp值为undefined 原因是 (m-1<0?0:dp[m-1][n]) + (n-1<0?0:dp[m][n-1])括号不能少，否则会变undefined
    6. 边界条件 只需要注意不要把已经初始化好的dp[0][0]干掉就行

- 不同路径II(63)
    1. dp[i][j] 表示到第i+1行第j+1列时的路径数
    2. 递推公式 dp[i][j] = obstacleGrid[i][j]===1?0:(((i-1<0||obstacleGrid[i-1][j]===1)?0:dp[i-1][j]) + ((j-1<0||obstacleGrid[i][j-1]===1)?0:dp[i][j-1]))
    3. 初始化 dp[0][0] = 1 
    4. 遍历顺序为从左到右 从上到下
    5. 打印
    6. 边界条件 如果obstacleGrid[0][0] === 1 则永远到不了终点

- 整数拆分(343)
    1. dp[i][j] 表示i被拆成j份时这些整数乘积的最大值
    2. 递推公式 dp[n][k] = Math.max(dp[n-1][k-1],dp[n-2][k-1]*2,dp[n-3][k-1]*3...) i<=n-k+1
    3. 初始化 dp[0][i] = 0 dp[i][1] = i 0 <= i <= n-1  这里只到n-1是因为切割的份数要大于2，让切1份的无效
    4. 遍历顺序 从左到右 从上到下 因为下一层的值依赖于上一列的值
    5. 打印，推导数组
    6. 边界条件处理 2 <= n <= 58 无额外边界处理

- 不同的⼆叉搜索树(96)
    1. dp[i] 的含义为i个节点的二叉搜索树种数
    2. 递推公式为 dp[i] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + d[2]*dp[n-3] + ... dp[n-1]*dp[0]
    3. 初始化dp[0] = 1,dp[1] = 1
    4. 遍历顺序，从小到大遍历，因为后数依赖前数
    5. 打印，边界条件处理
    